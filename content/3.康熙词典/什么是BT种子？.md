要想知道BT种子是什么，我们需要先说明计算机下载文件的一些方式。

# 1.通过中心服务器下载（C/S（Client/Server，客户端/服务器）模式）

在BT技术诞生前（现在也一样），下载文件的方式通常是通过某个中心服务器进行下载，例如通过应用商店下载软件、通过音乐软件下载音乐等。但是这种方式有两个很大的缺陷：第一，如果服务器带宽过窄而用户过多，所有人的下载速度会变慢；第二，如果中心服务器因故障或被封禁而停机，所有人将无法从该服务器下载文件。为了克服上述缺陷，BT（BitTorrent）技术应运而生。

# 2.通过BT技术下载

BT技术于2003年被Bram Cohen发明，用于解决传统C/S模式下载文件的不便之处。

BT技术在分享时需要资源发布者上传原始副本（做种），得到一个BT种子文件（以.torrent结尾），在分享时分享该种子文件。种子文件包含了种子创建时间、文件信息、文件长度、校验值等信息，其中还有Tracker（追踪器）服务器的地址和文件分块大小。

BT技术的下载原理是将文件分块后在下载者之间共享，这种技术也称为点对点（Peer To Peer，P2P）下载技术。这里我们假设有两用户A和B，且A下载了某文件的第a块，B下载了同一文件的第b块（a≠b），那么用户A和用户B可以交换彼此已经下载的分块。我们不难发现，当下载用户数量增多时，用户间的分块交换也会增多，下载速度也会提高。

Tracker服务器对于通过BT技术的下载非常关键。当我们打开某种子文件并开始下载时，Tracker会记录下我们的IP，并将其他正在下载或已经下载完成的用户的IP返回给我们，这样我们就可以找到其他下载同一个（批）文件的下载者了。如果Tracker因故障或被封禁而停机，我们便无法找到其他用户，也无法完成下载。

不难发现，Tracker服务器仍然是BT下载的缺陷所在。而为了解决由Tracker服务器带来的问题，磁力链接技术也开始问世。

# 3.通过磁力链接（Magnet URL scheme）技术下载

磁力链接的技术标准出现于2002年，最初是为了改进电驴（eDonkey2000）的ed2k链接等URL格式。

简单来说，磁力链接是一种特殊链接，其与BT技术的最大区别是：

- 弱化了Tracker服务器在下载中的地位；
- 使用文件散列函数值（哈希值）来定位文件；
- 可以通过Tracker以外的机制来寻找其他下载者。

磁力链接的标准格式如下：

```
magnet:?xt=urn:btih:40位文件哈希值
```

> [!IMPORTANT]
> 下面的内容较难理解，请读者根据自身情况选择阅读。如有错误请指出。

磁力链接通过DHT（Distributed Hash Table，分布式哈希表）机制寻找其他下载者。我们以Kadmlia协议（简称为Kad）为例说明。

一个想要加入网络的新节点（用户）需要先经过启动过程。在这个阶段，该节点需要知道另一个已经在 Kad 网络中注册的节点的 IP 地址 （通过另一个用户或储存的清单取得）。如果启动中的节点还不是网络的一部分，它便会计算一个尚未指定给其他节点的随机ID（160比特）编号。这个ID是由节点的对外IP地址跟端口号经过SHA-1算法计算之后得到的。这个 ID 会一直使用到离开网络为止。

在Kad网络中，每个节点都是一棵满二叉树的一个叶子，为简化说明，这里我们将160比特的ID简化为4位。那么根据前n位（1<=n<=4）的排列，我们可以将该完全二叉树分为4层，每个节点处在第4层。Kad协议可以确保每个节点知道至少一个节点，且各节点间都可以通过ID进行查找。

节点间距离的确定使用异或算法。二进制异或运算的运算规则如下：当异或运算的两数某位相同时，该位运算结果为0，否则为1。这里我们假设一个ID为0110的用户A，若有一用户的ID有且只有最后一位与该用户不同，我们很容易确定该用户ID为0111，计算两节点间距离为1，则对于用户A而言，该用户归为K-bucket 1。由此我们可以得出K-bucket的计算规则：

#### 对于某节点ID，若有用户的ID与该用户ID从倒数第n位开始不同，那么这样的用户数量有2<sup>i-1</sup>个，而这些节点与该用户的距离为\[2<sup>i-1</sup>,2<sup>i</sup>\]，对该用户而言，这样的节点归为K-bucket i。

我们假设用户A需要寻找ID为0011的用户B。计算两者之间的距离为0101，而1000>0101>0100，则该用户可能在K-bucket 3中。接下来，用户A检查自己的K-bucket 3中是否存在用户B，若存在，则查找停止。若不存在，则在该K-bucket中随机选择一用户C，向其请求B的位置。由于B与C在同一K-bucket中（这里为K-bucket 3），则B与C的倒数第3位相同，其距离小于0100。

C在收到来自A的请求后，用上述方法继续寻找用户B。若仍无法找到，则在C的K-bucket中再次随机选定用户D，由A向其请求用户B的位置，直到请求到B的位置。